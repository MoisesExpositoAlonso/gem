{
    "collab_server" : "",
    "contents" : "#include <stdlib.h>\n#include <gsl/gsl_rng.h>\n#include <gsl/gsl_randist.h>\n#include <random>\n#include <chrono>\n#include <ctime>\n\n#include <cstdio>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <list>\n#include <iostream>\n#include <string>\n\n\n// when armadillo is loaded, remove this below\n//#include <Rcpp.h>\n#include <RcppArmadillo.h>\n#include <RcppArmadilloExtensions/sample.h>\n#include <RcppEigen.h>\nusing namespace Rcpp;\nusing namespace std;\n\n\n#include <bigmemory/MatrixAccessor.hpp>\n#include <bigmemory/isna.hpp>\n\n// [[Rcpp::depends(BH, bigmemory)]]\n// [[Rcpp::depends(Rcpp)]]\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(RcppEigen)]]\n\n// Enable C++11 via this plugin (Rcpp 0.10.3 or later)\n// [[Rcpp::plugins(cpp11)]]\n\n////////////////////////////////////////////////////////////////////////////////\n/// Profiling utilities\n////////////////////////////////////////////////////////////////////////////////\n\n// RcppExport SEXP start_profiler(SEXP str) {\n//   ProfilerStart(as<const char*>(str));\n//   return R_NilValue;\n// }\n\n// RcppExport SEXP stop_profiler() {\n//   ProfilerStop();\n//   return R_NilValue;\n// }\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Utilities\n////////////////////////////////////////////////////////////////////////////////\ntypedef arma::Mat<double> mat;\ntypedef arma::Mat<int> mati;\ntypedef arma::vec vec;\n\n\n\n#define PBSTR \"||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"\n#define PBWIDTH 60\n\nvoid printProgress (double percentage)\n{\n  int val = (int) (percentage * 100);\n  int lpad = (int) (percentage * PBWIDTH);\n  int rpad = PBWIDTH - lpad;\n  printf (\"\\r%3d%% [%.*s%*s]\", val, lpad, PBSTR, rpad, \"\");\n  fflush (stdout);\n}\n\n\ntemplate <typename T>\nRcpp::NumericVector arma2vec(const T& x) {\n  return Rcpp::NumericVector(x.begin(), x.end());\n}\n\ntemplate <typename T>\narma::vec vec2arma(const T& x) {\n  return  Rcpp::as<arma::vec>(x);\n}\n\n// [[Rcpp::export]]\nNumericVector sample_num( NumericVector x,\n                          int size,\n                          bool replace,\n                          NumericVector prob = NumericVector::create()\n)\n{\n  NumericVector ret = RcppArmadillo::sample(x, size, replace, prob) ;\n  return ret ;\n}\n\n\n// #define MIN_NUM = std::numeric_limits<float>::min(); // problem is that it does not know the type\nconst double MIN_NUM = std::numeric_limits<float>::min();\n// #define PIraw = 3.14159265358979323846;\n// const double PI= 3.14159265358979323846;\n// # define PI 3.14159265358979323846  /* pi */\n//const double MAX_NUM = std::numeric_limits<float>::max();\n\n\n\n// arma::Mat<double> BMsubset(SEXP & A, const arma::uvec & mycols){\n//       Rcpp::XPtr<BigMatrix> bigMat(A);\n//       arma::Mat<double> X((double*) bigMat->matrix(), bigMat->nrow(), bigMat->ncol(), false, false);\n//                                       // consider saying true, perhaps is faster\n//       return(X.cols(mycols));\n// }\n// // [[Rcpp::export]]\n// arma::Mat<double> BMsubset(SEXP & A, const arma::uvec & mycols,const arma::uvec & myrows ){\n//       Rcpp::XPtr<BigMatrix> bigMat(A);\n//       arma::Mat<double> X((double*) bigMat->matrix(), bigMat->nrow(), bigMat->ncol(), false, false);\n//                                       // consider saying true, perhaps is faster\n//       return(X.submat(myrows,mycols));\n// }\n\n// [[Rcpp::export]]\narma::Mat<double> BMsubset(SEXP A, const arma::uvec & myrows, const arma::uvec & mycols ){\n      Rcpp::XPtr<BigMatrix> bigMat(A);\n      arma::Mat<double> X0((double*) bigMat->matrix(), bigMat->nrow(), bigMat->ncol(), false, false);\n                                      // consider saying true, perhaps is faster\n      // Subset matrix\n    \tif(myrows.n_elem == X0.n_rows){\n    \t\tX0=X0.cols(mycols);\n    \t}else if(mycols.n_elem == X0.n_rows){\n    \t  X0=X0.rows(myrows);\n    \t}else{\n    \t\tX0=X0.submat(myrows,mycols);\n    \t}\n      return(X0);\n}\n\n\n// [[Rcpp::export]]\narma::vec upperTmat(const arma::mat mat){\n  arma::vec output((mat.n_cols*(mat.n_cols-1))/2);\n  arma::mat::const_iterator it = mat.begin() + mat.n_rows; //iterator at rows to skip in every step, starts at second column\n  long toSkipInVec = 0;\n  for(int i = 1; i < mat.n_cols; i++) //Starts with 1 to skip the diagonal\n  {\n    std::copy(it, it + i, output.begin() + toSkipInVec);\n    toSkipInVec += i;\n    it += mat.n_rows;\n  }\n  return output;\n}\n\n// [[Rcpp::export]]\nmat Xmvcenter(mat X){\n  mat newX(X.n_rows,X.n_cols);\n  for(int j=0; j<X.n_cols; j++){\n   newX.col(j) = (X.col(j) - arma::mean( X.col(j))) /arma::stddev( X.col(j));\n  }\n  return(newX);\n}\n\n// [[Rcpp::export]]\narma::mat LDrelative(SEXP A, arma::uvec  m, bool debug = false){\n\n  Rcpp::XPtr<BigMatrix> bigMat(A);\n\tif(bigMat->matrix_type() !=8) stop(\"Big matrix is not of type double\");\n\n  // Read the genome matrix from address\n  arma::Mat<double> X((double*) bigMat->matrix(), bigMat->nrow(), bigMat->ncol(), false, false);\n  X=X.cols(m);\n\n  // mean and var center for LD calculation\n  X=Xmvcenter(X);\n  if(debug) cout << X << endl;\n\n  // Get the relative LD for the proposals\n  arma::mat R2 =  arma::trans(X)*X ;\n  if(debug)  cout << R2 << endl;\n  R2 = R2/ arma::sum(upperTmat(R2));\n  if(debug)  cout << arma::sum(upperTmat(R2)) << endl;\n  return(R2);\n}\n\narma::mat LDrelative(arma::mat X, bool debug = false){\n\n  // mean and var center for LD calculation\n  X=Xmvcenter(X);\n  if(debug) cout << X << endl;\n\n  // Get the relative LD for the proposals\n  arma::mat R2 =  arma::trans(X)*X ;\n  if(debug)  cout << R2 << endl;\n  R2 = R2/ arma::sum(upperTmat(R2));\n  if(debug)  cout << arma::sum(upperTmat(R2)) << endl;\n  return(R2);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Fitness functions\n////////////////////////////////////////////////////////////////////////////////\n\n\n/// Fitness class\nclass FITNESS{\n  private:\n    int mode;\n\n  public:\n\n    FITNESS(int m=1){\n      mode=m;\n    };\n\n    // fitness functions\n    double w(const double &s , const int &x, const double e=2){\n      switch(mode){\n        case 1:  // multiplicative\n          return 1 + (s * x) ;\n          break;\n        case 2:  // additive\n          return  (s * x) ;\n          break;\n        case 3:  // inverse multiplicative\n          // return 1 / (1 + s * x);\n          return pow((1 + s),x);\n          break;\n        default:  // multiplicative\n          return 1 - (s * x) ;\n          break;\n      }\n    }\n\n    // void operator +*=(double w, double s,int x,int mode)  // operator not needed unless class\n    void wupdate(double &prevw, const double &s,const int &x) {\n      switch(mode){\n        case 2:  // additive\n          prevw= prevw + w(s,x);\n          break;\n        default:  // additive\n          prevw= prevw * w(s,x);\n          break;\n      }\n    }\n};\n\n\n/// Expectation functions\n// [[Rcpp::export]]\narma::colvec Ey_go(const arma::Mat<double> & X, // careful arma::mat default is double\n                   const arma::colvec & s,\n                   const int & mode,\n                   double epi=1,\n                   double mu=1\n                   ){\n  /*\n  * Gamma expectation per haplotype - MULTIPLICATIVE MODEL\n  */\n\n  // Initialize class and set fitness model\n  FITNESS fit(mode);\n\n  // Initialize vector of distribution means\n  arma::colvec myprod(X.n_rows);\n  // myprod.fill(1);\n  myprod.fill(mu); // IMPORTANT\n\n  int i,j;\n  for (i = 0; i < X.n_cols; i ++) {\n      for( j=0; j < X.n_rows ; j++){\n        fit.wupdate(myprod(j),s(i),X(j,i)); // works because these expressions generate a reference\n      }\n  }\n  for( j=0; j<X.n_rows; j++) if(myprod(j)<0) myprod(j)=MIN_NUM; // **WARNING** this is necessary for non-NaN likelihood\n\n  if(epi!=1) myprod=pow(myprod,epi); // probably not very efficient\n  return(myprod);\n}\n\n\n\n // [[Rcpp::export]]\n double test_wfn (double s=0.1,double x=1, int m=1){\n  FITNESS fitfunction(m);\n  double myw=1;\n  fitfunction.wupdate( myw, s,  x);\n  return(myw);\n }\n// [[Rcpp::export]]\nvoid test_Ey_go(){\n  cout << \"Simulating 10 ind and 5 SNPs\" << endl;\n  arma::Mat<double> X(10, 5);\n  X.fill(0);\n  for(int j=0; j< X.n_cols; j++ ){\n    for(int i=0; i< X.n_rows; i++ ){\n      if(Rcpp::runif(1)(0) > 0.5){\n        X(i,j) =1;\n      }\n    }\n  }\n  cout << \"selection coefficients uniform\" << endl;\n  arma::vec s = Rcpp::runif(X.n_cols,0,1);\n\n  cout << \"Multiplicative \" << endl << Ey_go(X,s,1) << endl;\n  cout << \"Additive \" <<endl << Ey_go(X,s,2) << endl;\n  cout << \"Inverse \" << endl << Ey_go(X,s,5) << endl;\n\n}\n\n\n//\n// // [[Rcpp::export]]\n// arma::colvec Vy(const arma::colvec & y, const arma::colvec & h){\n//   /*\n//   * Variance of trait per genotype\n//   */\n//\n//   // Declarations\n//   arma::colvec hunique = unique(h);\n//   arma::colvec v(hunique.n_elem);\n//   // cout << hunique << endl;\n//\n//\n//   for(int i=0; i< hunique.n_elem; i++ ){\n//     // Create temporal vector\n//     arma::colvec ytmp;\n//     // Fill with all values corresponding to the same genotype\n//     for(int j=0; j<y.n_elem;j++){\n//       if(h(j) == hunique(i)) {\n//         ytmp.resize(ytmp.size()+1);\n//         ytmp(ytmp.size()-1) = y(j);\n//       }\n//     }\n//     // Compute variance\n//       if(ytmp.n_elem ==1){\n//         // v(i)=0;\n//         v(i)=-9;\n//       }else{\n//         v(i)=arma::var( ytmp );\n//       }\n//   }\n//   return(v);\n// }\n//\n//\n// // [[Rcpp::export]]\n// arma::colvec My(const arma::colvec & y, const arma::colvec & h){\n//   /*\n//   * Mean trait per genotype\n//   */\n//\n//   // Declarations\n//   arma::colvec hunique = unique(h);\n//   arma::colvec v(hunique.n_elem);\n//   // cout << hunique << endl;\n//\n//\n//   for(int i=0; i< hunique.n_elem; i++ ){\n//     // Create temporal vector\n//     arma::colvec ytmp;\n//     // Fill with all values corresponding to the same genotype\n//     for(int j=0; j<y.n_elem;j++){\n//       if(h(j) == hunique(i)) {\n//         ytmp.resize(ytmp.size()+1);\n//         ytmp(ytmp.size()-1) = y(j);\n//       }\n//     }\n//     // Compute variance\n//       if(ytmp.n_elem ==1){\n//        // v(i)=0;\n//        v(i)=ytmp(0);\n//       }else{\n//       v(i)=arma::mean( ytmp );\n//       }\n//   }\n//   return(v);\n// }\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Likelihood, Probabilities, Proposals\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n// [[Rcpp::export]]\ndouble runif_reflect(double minhere,double maxhere,double min,double max){\n  // int counter=1;\n  double newval;\n\n  if( min == max){\n    newval= min; // if values want to be kept constant\n  }else{\n    newval =Rcpp::runif(1,minhere,maxhere)(0);\n\n    if(newval<min){newval = (min-newval) + min;}\n    else if(newval>max){newval = max- (newval-max);}\n      // newval= runif_reflect(minhere,maxhere,min,max); // bad idea, segfault\n  }\n\n  // Check if it is out of bounds\n  if(newval < min || newval>max){\n    \tnewval=(max-min)/2;\n  }\n\n  return(newval);\n}\n\n// // Zero point mass proposal\n// // [[Rcpp::export]]\n// double pProposal(double & p, double min=0, double max=1, double bw=0.1){\n//     if(p<min || p> max){\n//     \tcout << \"Parameter p needs to be in between minimum and maximum!\" << endl;\n//     }\n// \t  double minhere=p-bw;\n//     double maxhere=p+bw;\n// \t\tdouble newval = runif_reflect(minhere,maxhere,min,max);\n//     return(newval);\n// }\n//\n// // [[Rcpp::export]]\n// double bProposal(double & b, double min=-0.01, double max=10, double bw=0.1){\n//     if(b<min || b> max){\n//     \tcout <<\"Parameter b needs to be in between minimum and maximum\"<< endl;\n//     }\n// \t\tdouble minhere=b-bw;\n// \t\tdouble maxhere=b+bw;\n// \t\tdouble newval = runif_reflect(minhere,maxhere,min,max);\n//   return(newval);\n// }\n//\n// // [[Rcpp::export]]\n// double aProposal(double & a, double min=-10, double max=10, double bw=0.1){\n//     if(a<min || a> max){\n//     \tcout <<\"Parameter a needs to be in between minimum and maximum\"<< endl;\n//     }\n// \t\tdouble minhere=a-bw;\n// \t\tdouble maxhere=a+bw;\n// \t\tdouble newval = runif_reflect(minhere,maxhere,min,max);\n//   return(newval);\n// }\n//\n// // [[Rcpp::export]]\n// double epiProposal(double & a, double min=-0.1, double max=5, double bw=0.1){\n//     if(a<min || a> max){\n//     \tcout <<\"Parameter epi needs to be in between minimum and maximum\"<< endl;\n//     }\n//\n//     double minhere=a-bw;\n//     double maxhere=a+bw;\n//     double newval = runif_reflect(minhere,maxhere,min,max);\n//   return(newval);\n// }\n//\n// double muProposal(double & a, double min=-0.1, double max=10, double bw=0.1){\n//     if(a<min || a> max){\n//     \tcout <<\"Parameter mu needs to be in between minimum and maximum\"<< endl;\n//     }\n//\n//     double minhere=a-bw;\n//     double maxhere=a+bw;\n//     double newval = runif_reflect(minhere,maxhere,min,max);\n//   return(newval);\n// }\n//\n//\n//  // [[Rcpp::export]]\n// void test_pProposal(double p=0.5){\n// \tcout << pProposal(p) << endl;\n// }\n//  // [[Rcpp::export]]\n// void test_bProposal(double b=0.2){\n// \tcout << bProposal\t(b) << endl;\n// }\n//  // [[Rcpp::export]]\n// void test_aProposal(double a=0.1){\n// \tcout << bProposal\t(a) << endl;\n// }\n//\n//  // [[Rcpp::export]]\n// void test_muProposal(double a=0.2){\n// \tcout << muProposal\t(a) << endl;\n// }\n//  // [[Rcpp::export]]\n// void test_epiProposal(double a=0.1){\n// \tcout << epiProposal(a) << endl;\n// }\n\nclass GPROPOSAL{\n\tprivate:\n\t\tdouble b; double bmin; double bmax;\n\t\tdouble a; double amin; double amax;\n\t\tdouble p; double pmin=0; double pmax=1;\n\t\tdouble mu; double mumin; double mumax;\n\t\tdouble epi; double epimin; double epimax;\n\t\tdouble svar; double svarmin; double svarmax;\n\t\tdouble ss; double ssmin; double ssmax;\n\t\tint nupdates=1;\n\t\tbool verbose;\n\t\tdouble bw;\n\n\tpublic:\n\t\tGPROPOSAL(\n            double b_=0.5,double bmin_=0,double bmax_=1,\n            double a_=0.1,double amin_=0,double amax_=1,\n\t\t\t\t\t\tdouble p_=0.5,\n\t\t\t\t\t\tdouble mu_=1,double mumin_=0, double mumax_=10,\n\t\t\t\t\t\tdouble epi_=1,double epimin_=0, double epimax_=5,\n\t\t\t\t\t\tdouble svar_=0.5,double svarmin_=0, double svarmax_=5,\n\t\t\t\t\t\tdouble ss_=0.1,double ssmin_=0, double ssmax_=1,\n\t\t\t\t\t\tdouble bw_=0.1,\n\t\t\t\t\t\tbool verbose_=false\n\t\t\t\t\t\t){\n\t\t\tb=b_;bmin=bmin_;bmax=bmax_;\n\t\t\ta=a_;amin=amin_;amax=amax_;\n\t\t\tp=p_;\n\t\t\tmu=mu_;mumin=mumin_;mumax=mumax_;\n\t\t\tepi=epi_;epimin=epimin_;epimax=epimax_;\n\t\t\tsvar=svar_;svarmin=svarmin_;svarmax=svarmax_;\n\t\t\tss=ss_;ssmin=ssmin_;ssmax=ssmax_;\n\t\t\tbw=bw_;\n\t\t\tverbose=verbose_;\n\t\t}\n\t\tvoid setupdatesnum(int ups){nupdates=ups;}\n\t\tvoid setverbose(bool verbose_){verbose=verbose_;}\n\t  void printatributes(){\n\t    cout <<\"bw = \" << bw << endl;\n\t  \tcout <<\"b = \" << b << \" \" << bmin << \" \" << bmax << endl;\n\t  \tcout <<\"a = \" << a << \" \" << amin << \" \" << amax << endl;\n\t  \tcout <<\"p = \" << p << \" \" << pmin << \" \" << pmax << endl;\n\t  \tcout <<\"mu = \" << mu << \" \" << mumin << \" \" << mumax << endl;\n\t  \tcout <<\"epi = \" << epi << \" \" << epimin << \" \" << epimax << endl;\n\t  \tcout <<\"svar = \" << svar << \" \" << svarmin << \" \" << svarmin << endl;\n\t  \tcout <<\"ss = \" << ss << \" \" << ssmin << \" \" << ssmin << endl;\n\t  }\n    arma::vec fn(arma::vec g){\n\n      // New proposal\n      arma::vec news=g;\n\n      // Update one position\n      double minhere,maxhere;\n      double newval;\n\n      if(verbose) cout << \"Loop to substitute position\" << endl;\n      for(int j=0; j< nupdates; j++){\n        int randomIndex = rand() % g.size();\n        minhere=g(randomIndex)-bw;\n        maxhere=g(randomIndex)+bw;\n        switch(randomIndex){\n            if(verbose) cout << g(randomIndex) << endl;\n          \tcase 0: newval= runif_reflect(minhere,maxhere,bmin,bmax); break;\n          \tcase 1: newval= runif_reflect(minhere,maxhere,amin,amax); break;\n          \tcase 2: newval= runif_reflect(minhere,maxhere,pmin,pmax); break;\n          \tcase 3: newval= runif_reflect(minhere,maxhere,mumin,mumax); break;\n          \tcase 4: newval= runif_reflect(minhere,maxhere,epimin,epimax); break;\n          \tcase 5: newval= runif_reflect(minhere,maxhere,svarmin,svarmax); break;\n          \tcase 6: newval= runif_reflect(minhere,maxhere,ssmin,ssmax); break;\n        }\n        if(verbose) cout << newval << endl;\n        news(randomIndex) = newval;\n      }\n      if(verbose) cout << \"End loop\" << endl;\n\n      return(news);\n  }\n};\n\n\n\n// [[Rcpp::export]]\nvoid test_GProposal(double b=1,double a=1,\n                    double p=1, double mu=1,\n                    double epi=1, double svar=1,double ss=0.1,\n                    int iter=3,bool verbose = true){\n\n  arma::vec g(6);\n  g(0)= b;\n  g(1)= a;\n  g(2)= p;\n  g(3)= mu;\n  g(4)= epi;\n  g(5)= svar;\n  g(6)= ss;\n\n  GPROPOSAL GProp; // mode 1 = uniform ; mode 2 = LD\n  GProp.setverbose(verbose);\n  GProp.printatributes();\n  cout << \"Original \" << endl;\n  cout << g << endl;\n  cout << \"Testing proposals \"<< endl;\n\tfor(int i=0; i<iter; i++){\n\t\tg=GProp.fn(g);\n\t\tcout <<  g<< endl;\n\t}\n\n}\n          //   gproposal=GProp.fn(par_chain.col(i));\n\n///////////////////////////////////////////////////////////////////////////////\n// Selection proposal with LD\nclass PROPOSAL {\n  private:\n    double bw;\n    int nupdates;\n    double min;\n    double max;\n    int mode;\n    bool verbose;\n    arma::mat R; // for LD implementatioon\n\n\n  public:\n  PROPOSAL(\n            int nupdates_,\n            int mode_=1\n            ){\n    nupdates=nupdates_;\n    mode=mode_;\n    verbose=false;\n    }\n  PROPOSAL(\n            double bw_,\n            int nupdates_,\n            double min_,\n            double max_,\n            int mode_=1,\n            bool verbose_= false\n            ){\n    bw=bw_;nupdates=nupdates_;min=min_;max=max_;mode=mode_;verbose=verbose_;\n    // initialize R2 for default cases\n    arma::mat onemat(1,1);\n    onemat.fill(1);\n    R=onemat;\n    }\n  PROPOSAL(arma::mat R2,\n            double bw_,\n            int nupdates_,\n            double min_,\n            double max_,\n            int mode_=1,\n            bool verbose_= false\n            ){\n    bw=bw_;nupdates=nupdates_;min=min_;max=max_;mode=mode_;verbose=verbose_;\n    // initialize R2 for default cases\n    R=R2;\n    }\n\n  void printatributes(){\n    cout <<\"bw = \" << bw << endl;\n    cout <<\"nupdates = \" <<nupdates << endl;\n    cout <<\"min = \" << min << endl;\n    cout <<\"max = \" <<max << endl;\n    cout <<\"mode = \" <<mode << endl;\n    cout <<\"verbose = \" <<verbose << endl;\n  }\n arma::vec fn(arma::vec s){\n    switch(mode){\n      case 1:\n        return update(s);\n        break;\n      case 2:\n        return updateLD(s);\n        break;\n      default:\n        return update(s);\n        break;\n    }\n  }\n  arma::vec fn(arma::vec s, double svar){\n    switch(mode){\n      case 1:\n        return update(s);\n        break;\n      case 2:\n        return updateLD(s);\n      case 3:\n        return updatelog(s,svar);\n        break;\n      default:\n        return update(s);\n        break;\n    }\n  }\n\n\n   arma::vec update(arma::vec s){\n      /*\n      * Make proposal change of one or more selection coefficients\n      * from a previous vector.\n      * Do not allow to go further thana bandwidth of 0.1\n      */\n      // New proposal\n      arma::colvec news=s;\n\n      // Update one position\n      double minhere,maxhere,newval;\n\n      if(verbose) cout << \"Loop to substitute position\" << endl;\n      for(int j=0; j< nupdates; j++){\n\n        int randomIndex = rand() % s.size();\n        minhere=s(randomIndex)-bw;\n        maxhere=s(randomIndex)+bw;\n    \t\tnewval = runif_reflect(minhere,maxhere,min,max);\n        news(randomIndex) = newval;\n      }\n      if(verbose) cout << \"End loop\" << endl;\n\n      return(news);\n  }\n    arma::vec updatelog(arma::vec s,double svar){\n      // New proposal\n      arma::colvec news= s;\n\n      // Update one position\n      double meanhere,newval;\n\n      if(verbose) cout << \"Loop to substitute position\" << endl;\n      for(int j=0; j< nupdates; j++){\n\n        int randomIndex = rand() % s.size();\n      \tmeanhere=log(1+s(randomIndex));\n      \tif(isinf(meanhere)){\n            meanhere= (max-min)/2;\n          }\n\n    \t\tnewval = Rcpp::rnorm(1,0,svar)(0);\n\n        news(randomIndex) = exp(newval)-1;\n        if(verbose) cout << newval << endl;\n        if(verbose) cout << news(randomIndex) << endl;\n      }\n      if(verbose) cout << \"End loop\" << endl;\n\n      return(news);\n  }\n  arma::vec updateLD(arma::vec s){\n    // New proposal\n      arma::colvec news=s;\n\n      // Update one position\n      double minhere,maxhere,newval;\n\n      if(verbose) cout << \"Loop to substitute position\" << endl;\n\n      int randomIndex = rand() % s.size();\n      minhere=s(randomIndex)-bw;\n      maxhere=s(randomIndex)+bw;\n      newval = runif_reflect(minhere,maxhere,min,max);\n      news(randomIndex) = newval;\n\n      double diff = news(randomIndex) - s(randomIndex);\n      if(verbose) cout << \"Difference with original value = \" << diff << endl;\n\n      for(int i=0; i<s.n_elem & i!= randomIndex; i++){\n        news(i) -= diff * R(randomIndex,i) ;\n        if(verbose) cout << news(i) << endl;\n          if(news(i) < min) news(i) =min+abs(news(i) -min);\n          if(news(i) > max) news(i) =max-abs(news(i) -max);\n      }\n      return(news);\n  }\n\n};\n\n// [[Rcpp::export]]\narma::vec PropoS(int nupdates,double svar = 0.5){\n\n\tarma::vec s(nupdates);\n\ts.fill(0);\n\n\tPROPOSAL ps(nupdates,3);\n\n\treturn(ps.fn(s,svar));\n}\n\n// [[Rcpp::export]]\nvoid test_ProposalsLD(\n                    mat X,\n                    double min=0,\n                    double max=1,\n                    double bw=0.1,\n                    int nupdates=1,\n                    int mode=2,\n                    int iterations=1,\n                    bool verbose=true\n                    ){\n\n  arma::vec s = Rcpp::runif(X.n_cols,0,1);\n  PROPOSAL Prop(LDrelative(X),bw,nupdates,min,max,2,verbose); // mode 1 = uniform ; mode 2 = LD\n\n  cout << \"Original \" << endl;\n  // cout << s << endl;\n  cout << \"Testing proposals under mode = \"<< mode << endl;\n  for(int i=0; i<3; i++){\n    s=Prop.fn(s);\n    // cout << s << endl;\n  }\n}\n\n\n// [[Rcpp::export]]\narma::vec call_Proopsals(\n                        arma::vec s,\n                        int m=10,\n                        double min=0,\n                        double max=1,\n                        double bw=0.1,\n                        int nupdates=1,\n                        int mode=1,\n                        bool verbose=true){\n\n\n  PROPOSAL Prop(bw,nupdates,min,max,mode,verbose); // mode 1 = uniform ; mode 2 = LD\n  Prop.printatributes();\n\n  return Prop.fn(s);\n}\n\n// [[Rcpp::export]]\nvoid test_Proposals(int m=10,\n                    double min=0,\n                    double max=1,\n                    double bw=0.1,\n                    int nupdates=1,\n                    int mode=1,\n                    int iterations=3,\n                    bool verbose=true\n                    ){\n\n  arma::vec s = Rcpp::runif(m,0,1);\n  PROPOSAL Prop(bw,nupdates,min,max,mode,verbose); // mode 1 = uniform ; mode 2 = LD\n\n  Prop.printatributes();\n\n  cout << \"Testing proposals under mode = \"<< mode << endl;\n  for(int i=0; i<3; i++){\n    s=Prop.fn(s);\n    cout << s << endl;\n  }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nclass PRIOR{\n\npublic:\n  double min;\n  double max;\n  double mean;\n  double svar;\n  double ss;\n  int mode;\n\n// Constructors\n\n // PRIOR(double min_=0,double max_=1,\n //        double mean_=0,double variance_=1,\n //        int mode_=1){\n //  min=min_; max=max_;mean=mean_; variance=variance_; mode=mode_; };\n\n  PRIOR(double par1=0,double par2=1, int mode_=1){\n       mode=mode_;\n      switch(mode){\n        case 1: // moc mode, return 1\n          break;\n        case 2: // true uniform\n          min=par1;\n          max=par2;\n          break;\n        case 3: // log +1 normal\n          mean=par1;\n          svar=par2;\n          break;\n      case 4: // log +1 mixture normal with sparcity\n          svar=par1;\n          ss=par2;\n          break;\n        default:\n          min=0;max=1;mean=0,svar=0.5;\n          break;\n    }\n  }\n\n  void printatributes(){\n    cout <<\"min = \" << min << endl;\n    cout <<\"max = \" <<max << endl;\n    cout <<\"s variance = \" <<svar << endl;\n    cout <<\"mode = \" <<mode << endl;\n  }\n// Prior functions\n  double uniform(const arma::colvec & s){\n    double L= 0;\n    int N=s.n_elem;\n    for(int i=0;i<N ;i++){\n      L+= R::dunif(s(i),min,max,true);\n    }\n    return L;\n  }\n  double loggaussian(const arma::colvec & s, double svar){\n    // int n=s.n_elem;\n  \tarma::vec x = log(1+s);\n    // double L = -.5*n*log(2*PI) -.5*n*log(svar) -(1/(2*svar))*sum(arma::pow((x-mean),2));\n    double L=0;\n    for(int i = 0; i<s.n_elem; i++){\n      L+= R::dnorm(x(i),0,svar,true);\n    }\n    return L;\n  }\ndouble logmixgaussian(const arma::colvec & s, double svar, double ss){\n\n  \tarma::vec x = log(1+s);\n\n    double L=0;\n    for(int i = 0; i<s.n_elem; i++){\n      // L+= R::dnorm(x(i),0,svar,true);\n      if(x(i)==0){\n        L += log(ss  + (1-ss) * R::dnorm(x(i),0,svar,false)) ;\n      }else{\n    \t  L += (1-ss) * R::dnorm(x(i),0,svar,true);\n      }\n    }\n    return L;\n  }\n  // Prior distributor\n  double fn(const arma::colvec & s){\n    switch(mode){\n      case 1: // moc mode, return 1\n        return 1.0; break;\n      case 2: // true uniform\n        return uniform(s); break;\n      default:\n        return 1.0; break;\n    }\n  }\n  double fn(const arma::colvec & s,const double & svar,const double & ss){\n        switch(mode){\n      case 1: // moc mode, return 1\n        return 1.0; break;\n      case 2: // true uniform\n        return uniform(s); break;\n      case 3:\n    \t\treturn loggaussian(s,svar); break;\n      case 4:\n        return logmixgaussian(s,svar,ss); break;\n      default:\n        return 1.0; break;\n    }\n  }\n};\n\n\n// [[Rcpp::export]]\nvoid test_Prior(int m=10,\n                double min=0,\n                double max=1,\n                double mean=0,\n                double variance=1,\n                double sparsity=0.1,\n                int mode=1\n                    ){\n\n  arma::vec s;\n\n  if(mode==1){\n    s = exp( Rcpp::rnorm(m,0,variance) ) - 1;\n  }else{\n    s = Rcpp::runif(m,0,1);\n  }\n  cout << s << endl;\n\n  cout << \"Prior mode = 1\" << endl;\n  PRIOR Pri; // mode 1 = uniform moc\n  cout << Pri.fn(s) << endl;\n\n  cout << \"Prior mode = 2\" << endl;\n  PRIOR Pri2(min,max,2); // mode 1 = uniform moc\n  cout << Pri2.fn(s) << endl;\n\n  cout << \"Prior mode = 3\" << endl;\n  PRIOR Pri3(mean,variance,3); // mode 1 = uniform moc\n  cout << Pri3.fn(s,variance,sparsity) << endl;\n\n  cout << \"Prior mode = 4\" << endl;\n  PRIOR Pri4(mean,variance,4); // mode 1 = uniform moc\n  cout << Pri3.fn(s,variance,sparsity) << endl;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n// [[Rcpp::export]]\narma::vec hsub(const arma::vec & h){\n  arma::vec hunique = unique(h);\n  arma::vec hpos(h.n_elem);\n  for(int i=0; i<h.n_elem;i++){\n    for(int j=0; j< hunique.n_elem;j++){\n      if(h(i) == hunique(j)) hpos(i) = j;\n    }\n  }\n  return(hpos);\n}\n\n// [[Rcpp::export]]\ndouble trialLL(double hs=10){\n\n\tarma::vec e(20);\n\te.fill(2);\n\n\treturn e(hs);\n\n}\n// [[Rcpp::export]]\ndouble LLGaussMix(double y,double e,double v,double p){\n  double LL;\n  if(y==0){\n    LL = p  + (1-p) *  R::pnorm(0,e,v,true,false) ;\n  }else{\n  \tLL = (1-p) * R::dnorm(y,e,v,false);\n  }\nreturn log(LL);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Likelihood class\n\nclass LIKELIHOOD{\n  private:\n    int mode;\n    bool TEST;\n    bool verbose;\n    arma::vec y;\n    arma::vec h;\n    arma::Mat<double> X;\n\n\n  public:\n  //Constructor\n     LIKELIHOOD(\n           const arma::vec  y_,\n           const arma::vec  h_,\n           const arma::Mat<double>  X_, // careful the arma::mat by default is double\n           int mode_=1,\n           bool TEST_=false,\n           bool verbose_=false){\n\n          y=y_; h=h_; X=X_;\n          mode=mode_;TEST=TEST_;verbose=verbose_;\n     }\n\n  void printatributes(){\n    cout <<\"verbose = \" << verbose << endl;\n    cout <<\"TEST = \" <<TEST << endl;\n    cout <<\"mode = \" <<mode << endl;\n  }\n\n\t// calling function\n    double fn(const arma::vec & s, double b,double a, double p,double mu=1,double epi=1){\n      if(TEST) return 1.0;\n      else return LLikfn(s,b,a,p,mu,epi);\n    }\n\n  // likelihood function\n  double LLikfn(const arma::vec & s, double b,double a, double p,double mu=1,double epi=1){\n      /*\n      * Summed log likelihood of all genotypes following each a Gammma distribution\n      * inferred from sampling variance, mean observed genotype and selection a\n      * set of selection coefficients\n      */\n\n\n      // Precompute all expectations of mean fitness values given genotypes X and s.\n      if(verbose) cout<< \"Precompute expectations...\"<<  endl;\n      arma::vec e= Ey_go(X,s,mode,epi,mu);\n      // cout << e<< endl; // for debugging\n      arma::vec v= a+abs(e*b);\n      // cout << v<< endl; // for debugging\n\n      // Utilities\n      arma::vec hs=hsub(h);\n\n      // Sum likelihood over all genotypes\n      if(verbose) cout<< \"Calculating likelihood over all genotypes...\"<<  endl;\n      int i;\n      double L=0;\n      double LL;\n        for(i=0; i< y.n_elem ; i ++){\n          LL= LLGaussMix(y(i),e(hs(i)),v(hs(i)),p);\n          if(verbose and isinf(LL)){\n            cout << \"---\" << endl;\n            cout << i << endl;\n            cout << y(i) << \" \"<< e(hs(i)) << \" \"<< v(hs(i)) <<\" \"<< p << endl;\n            cout << LL << endl;\n          }\n          L += LL;\n        }\n\n\n      return(L);\n    }\n};\n\n\n// [[Rcpp::export]]\nvoid test_Likelihood(\n                SEXP A,\n                arma::vec y,\n                arma::vec h,\n                arma::vec s,\n                double b,\n                double a,\n                double p,\n                arma::uvec m,\n                arma::uvec n,\n                int Fitnessmode=1,\n                bool TEST=false,\n                bool verbose=true\n                    ){\n\n  arma::Mat<double> X=BMsubset(A,n,m);\n  cout << \"Selection coefficients\" << endl;\n  cout << s << endl;\n\n  cout << \"Likelihood\" << endl;\n  LIKELIHOOD LL(y,h,X,Fitnessmode,TEST,verbose);\n  cout << LL.fn(s,b,a,p) << endl;\n}\n\n\n\n// [[Rcpp::export]]\nvoid test_Likelihoodall(\n                SEXP A,\n                arma::vec y,\n                arma::vec h,\n                arma::vec s,\n                double b,\n                double a,\n                double p,\n                arma::uvec m,\n                arma::uvec n,\n                int mode=1,\n                bool verbose=true\n                    ){\n\n  arma::Mat<double> X=BMsubset(A,n,m);\n  cout << \"Selection coefficients\" << endl;\n  cout << s << endl;\n\n  cout << \"Likelihood mode = 1 | TEST = false\" << endl;\n  LIKELIHOOD LL1(y,h,X,mode,false,verbose);\n  cout << LL1.fn(s,b,a,p) << endl;\n\n  cout << \"Likelihood mode = 1 | TEST = true\" << endl;\n  LIKELIHOOD LL2(y,h,X,mode,true,verbose);\n  cout << LL2.fn(s,b,a,p) << endl;\n\n  cout << \"Likelihood mode = 2 \" << endl;\n  LIKELIHOOD LL3(y,h,X,2,false,verbose);\n  cout << LL3.fn(s,b,a,p) << endl;\n\n  cout << \"Likelihood mode = 3 \" << endl;\n  LIKELIHOOD LL4(y,h,X,3,false,verbose);\n  cout << LL4.fn(s,b,a,p) << endl;\n\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// MCMC\n////////////////////////////////////////////////////////////////////////////////\n\n\n// [[Rcpp::export]]\nList gwsMCMC(\n\t\t\t\t\t\tconst arma::vec & y,\n            const arma::vec & h,\n            SEXP A, // instead of arma::mat X,\n            const arma::colvec & s,\n            const arma::uvec m, // the positions of SNPs\n            const arma::uvec n , // the positions of individuals\n\t\t\t\t\t\tdouble b=0.5, double bmin=0, double bmax=1.0, // the mean variance transformation\n\t\t\t\t\t\tdouble a=0.1, double amin=0.0, \tdouble amax=1, // the intercept of variance\n\t\t\t\t\t\tdouble p=0.5, // the proportion of zero values\n\t\t\t\t\t\tdouble mu=1.0, double mumin=0,double mumax=10,\n\t\t\t\t\t\tdouble epi=1.0, double epimin=1.0,double epimax=1.0,\n\t\t\t\t\t\tdouble svar=0.1, double svarmin=0,double svarmax=1,\n\t\t\t\t\t\tdouble ss=0.1, double ssmin=0,double ssmax=1,\n\t\t\t\t\t\tdouble bw= 0.1, // the maximum size of jumps of global parameters\n\t\t\t\t\t\tint nupdates=1,\n\t\t\t\t\t\tdouble min=1e-6,\n\t\t\t\t\t\tdouble max=1-1e-6 ,\n\t\t\t\t\t\tdouble iterations = 1e4,\n\t\t\t\t\t\tbool TEST =false ,\n\t\t\t\t\t\tbool verbose=false,\n\t\t\t\t\t\tbool debug=false,\n\t\t\t\t\t\tint Fitnessmode=1,\n\t\t\t\t\t\tint Priormode=1,\n\t\t\t\t\t\tint Proposalmode=1,\n\t\t\t\t\t\tstd::string file2sink= \"output.log\",\n\t\t\t\t\t\tbool sink2file = false\n\t\t\t\t\t\t){\n\n      if(sink2file) std::freopen(file2sink.c_str(), \"w\", stdout);\n\n      cout<< \"Arguments:\"<<endl;\n      cout<< \"----------\"<<endl;\n      cout<< \"Range of s coefficients = [\"<< min << \", \" << max << \"]\" <<endl;\n      cout<< \"Total number of individual's observations = \"<<  y.n_elem <<endl;\n      cout<< \"Total number of SNPs = \"<<  s.n_elem <<endl;\n\n      cout<< \"# iterations = \"<< iterations <<endl;\n      cout<< \"TEST run = \"<< TEST <<endl;\n      cout<< \"Verbose = \"<< verbose <<endl;\n      cout<< \"Debug = \"<< debug <<endl;\n\n      cout<< \"----------\"<<endl;\n      cout<< \"Initializing ... \"<<endl;\n      std::chrono::time_point<std::chrono::system_clock> start, end; // start chronometer values\n      start = std::chrono::system_clock::now();\n\n\n     ///////////////////////////////////////////////////////////////////////////\n     // Deal with the matrix //\n     ///////////////////////////////////////////////////////////////////////////\n\n\t\t arma::Mat<double> X;\n// \t\t if(n.n_elem != A){\n//        cout<< \"Reading and subsetting genome matrix ... \"<<endl;\n// \t\t   X=BMsubset(A,n,m);\n// \t\t }else{\n//       cout<< \"Reading and subsetting columns ... \"<<endl;\n// \t\t   X=BMsubset(A,m);\n// \t\t }\n     cout<< \"Reading and subsetting genome matrix ... \"<<endl;\n\t   X=BMsubset(A,n,m);\n\n     ///////////////////////////////////////////////////////////////////////////\n     // Setup MCMC //\n     ///////////////////////////////////////////////////////////////////////////\n\n      // Counter for printing\n      int counter = 0;\n      double percentunit = iterations/100;\n\n      // Initialize chain object\n      arma::mat s_chain(s.n_elem,iterations+1);\n      arma::mat par_chain(7, iterations+1);      /// update when adding new par\n\n      arma::vec  prob(iterations+1);\n      arma::vec  paccepts(iterations+1);\n\n\n      int naccepted=0;\n      double prob0;\n      double prob1;\n      double Paccept;\n    \tbool accept;\n\n      double selectionpar= s.n_elem ;\n      double globalpar= par_chain.n_rows;\n      double totpar= selectionpar + globalpar; // CHANGE WHEN ADDING MORE PARAMETERS\n      if(debug) cout << \"Total selection parameters = \" << (selectionpar) << endl;\n      if(debug) cout << \"Total global parameters = \" << (globalpar) << endl;\n      if(debug) cout << \"Total # of parameters = \" << (totpar) << endl;\n\n\n     \t///////////////////////////////////////////////////////////////////////////\n     // Setup MCMC conditions //\n     ///////////////////////////////////////////////////////////////////////////\n\n\n      // Proposals for variables\n      arma::vec  sproposal=s;\n      arma::vec gproposal(7); // Need to keep right order\n      gproposal(0)=b;\n      gproposal(1)=a;\n      gproposal(2)=p;\n      gproposal(3)=mu;\n      gproposal(4)=epi;\n      gproposal(5)=svar;\n      gproposal(6)=ss;\n      cout << \"First proposal of global paramenters: \"<< endl;\n      cout <<\"b = \"<< gproposal(0)<<endl;\n\t\t\tcout <<\"a = \" <<gproposal(1)<<endl;\n      cout <<\"p = \" <<gproposal(2)<<endl;\n      cout <<\"mu = \" <<gproposal(3)<<endl;\n      cout <<\"epi = \" <<gproposal(4)<<endl;\n      cout <<\"svar = \" <<gproposal(5)<<endl;\n      cout <<\"ss = \" <<gproposal(6)<<endl;\n      Rcpp::StringVector parnames(gproposal.n_elem);\n      parnames(0)=\"b\";\n      parnames(1)=\"a\";\n      parnames(2)=\"p\";\n      parnames(3)=\"mu\";\n      parnames(4)=\"epi\";\n      parnames(5)=\"svar\";\n      parnames(6)=\"ss\";\n\n\n      // Compute prob at first step\n      cout<< \"Start chains ...\"<<endl;\n      s_chain.col(0) = s; // set start as starting value\n      par_chain.col(0) = gproposal;\n\n       // Setup probability objects\n      LIKELIHOOD LL(y,h,X,Fitnessmode,TEST,false);\n      PRIOR Pri(0,svar, Priormode); // loggauss\n      // PRIOR Pri(min,max, Priormode); // uniform\n\n            // Proposal Prop(R,bw,nupdates,min,max,Proposalmode); // to implement R2\n      PROPOSAL Prop(bw,\n                    nupdates,\n                    min,\n                    max,\n                    Proposalmode);\n\t\t\tGPROPOSAL GProp(b,bmin,bmax,\n                   \t\ta, amin,amax,\n                   \t\tp,\n                   \t\tmu,mumin,mumax,\n                   \t\tepi,epimin,epimax,\n                   \t\tsvar,svarmin,svarmax);\n\n     \tpaccepts(0)=1;\n      cout<< \"Calculate posterior of starting point ...\" ;\n      prob(0) = Pri.fn(sproposal, gproposal(5),gproposal(6)) +\n      \t\t\t\t\tLL.fn(sproposal,\n\t \t\t\t\t\t\t\tgproposal(0),\n\t \t\t\t\t\t\t\tgproposal(1),\n\t \t\t\t\t\t\t\tgproposal(2),\n\t \t\t\t\t\t\t\tgproposal(3),\n\t \t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n      cout << prob(0) << endl;\n      if(isinf(prob(0))){\n      \tcout << \"Posterior is infinite!!!. Attempting change in stargin values\" << endl;\n      \tPROPOSAL Propattempt(bw,\n\t\t\t\t                     s.n_elem,\n\t\t\t\t                     min,\n\t\t\t\t                     max,\n\t\t\t\t                     Proposalmode);\n\t\t\t\twhile(!isinf(prob(0))){\n\t\t\t\t\tsproposal = Propattempt.fn(s);\n\t\t\t\t\tprob(0) =\n\t\t\t\t\t\t\t\t\t\tPri.fn(sproposal, gproposal(5),gproposal(6)) +\n\t\t\t\t\t\t\t\t\t\t// Pri.fn(sproposal) +  // Previous implementation\n\t\t\t\t\t\t\t\t\t\tLL.fn(sproposal,\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(0),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(1),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(2),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(3),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n      }\n\n\t\t  ///////////////////////////////////////////////////////////////////////////\n     // run MCMC  //\n     ///////////////////////////////////////////////////////////////////////////\n\n      cout<< \"Starting \"<< iterations<< \" MCMC iterations ...\"<<endl;\n      int counterupdate=0;\n\t\t\tint i;\n        for(i=0; i<iterations;i++){\n\n          // // Propose new s and new probability\n          if(verbose) cout<< \"Generating new proposal \"<<endl;\n\n          if(counterupdate <= selectionpar){\n            sproposal=Prop.fn(s_chain.col(i),gproposal(5));\n            counterupdate++;\n          }else if(counterupdate < totpar ){\n            gproposal=GProp.fn(par_chain.col(i));\n            counterupdate++;\n          }else{\n            counterupdate=0;\n          }\n\n          // Probabilities\n          if(verbose) cout<< \"Calculating next posterior \"<<endl;\n          prob0= prob(i);\n          prob1 = Pri.fn(sproposal, gproposal(5),gproposal(6))+\n          \t\t\t\tLL.fn(sproposal,\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(0),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(1),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(2),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(3),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n    \t\t\t// if(debug) cout << prob1<< endl;\n\n            // Ratio of provabilities\n    \t\t\t\tPaccept= exp( prob1 - prob0);\n            accept = Rcpp::runif(1)(0)<Paccept;\n            if(verbose) cout<< \"Accept proposal \" << accept <<endl;\n\n            if(accept){\n              s_chain.col(i+1) = sproposal;\n              par_chain.col(i+1) = gproposal;\n\n              prob(i+1) = prob1;\n              paccepts(i+1) = Paccept;\n              naccepted++;\n            }else{\n              s_chain.col(i+1) = s_chain.col(i);\n              par_chain.col(i+1) = par_chain.col(i);\n\n              prob(i+1) = prob(i);\n              paccepts(i+1) = paccepts(i);\n            }\n\n            // Print row\n            if(counter > percentunit){\n              if(!debug & !sink2file) printProgress(i/iterations);\n              counter =0;\n            }else{\n              counter++;\n            }\n\n        }\n        printProgress(1);\n\n\t\t\t/////////\n      // End //\n      /////////\n      cout<< endl<< \"Summary:\"<<endl;\n      cout<< \"----------\"<<endl;\n      cout<< \"Acceptance ratio = \"<< naccepted / iterations << endl;\n      cout<< \"Final posterior = \"<< prob(iterations) << endl;\n      cout<< \"----------\"<<endl;\n      cout<<endl<< \"Done.\"<<endl;\n        end = std::chrono::system_clock::now();\n        std::chrono::duration<double> elapsed_seconds1 = end-start;\n        std::cout << \"elapsed time: \" << elapsed_seconds1.count() << \" seconds\" <<endl;\n\n     return List::create(Named(\"chain\") = s_chain.t(),\n                         Named(\"parchain\") = par_chain.t(),\n                         Named(\"parnames\") = parnames,\n                         Named(\"posterior\") = prob,\n                         Named(\"accept\") = paccepts);\n  }\n\n// [[Rcpp::export]]\nList gwsMC3(\n\t\t\t\t\t\tconst arma::vec & y,\n            const arma::vec & h,\n            SEXP A, // instead of arma::mat X,\n            const arma::colvec & s,\n            const arma::uvec m, // the positions of SNPs\n            const arma::uvec n , // the positions of individuals\n\t\t\t\t\t\tdouble b=0.5, double bmin=0, double bmax=1.0, // the mean variance transformation\n\t\t\t\t\t\tdouble a=0.1, double amin=0.0, \tdouble amax=1, // the intercept of variance\n\t\t\t\t\t\tdouble p=0.5, // the proportion of zero values\n\t\t\t\t\t\tdouble mu=1.0, double mumin=0,double mumax=10,\n\t\t\t\t\t\tdouble epi=1.0, double epimin=1.0,double epimax=1.0,\n\t\t\t\t\t\tdouble svar=0.1, double svarmin=0,double svarmax=1,\n\t\t\t\t\t\tdouble ss=0.1, double ssmin=0,double ssmax=1,\n\t\t\t\t\t\tdouble bw= 0.1, // the maximum size of jumps of global parameters\n\t\t\t\t\t\tint nupdates=1,\n\t\t\t\t\t\tdouble min=1e-6,\n\t\t\t\t\t\tdouble max=1-1e-6 ,\n\t\t\t\t\t\tdouble iterations = 1e4,\n\t\t\t\t\t\tbool TEST =false ,\n\t\t\t\t\t\tbool verbose=false,\n\t\t\t\t\t\tbool debug=false,\n\t\t\t\t\t\tint Fitnessmode=1,\n\t\t\t\t\t\tint Priormode=1,\n\t\t\t\t\t\tint Proposalmode=1,\n\t\t\t\t\t\tstd::string file2sink= \"output.log\",\n\t\t\t\t\t\tbool sink2file = false\n\t\t\t\t\t\t){\n\n      if(sink2file) std::freopen(file2sink.c_str(), \"w\", stdout);\n\n      cout<< \"Arguments:\"<<endl;\n      cout<< \"----------\"<<endl;\n      cout<< \"Range of s coefficients = [\"<< min << \", \" << max << \"]\" <<endl;\n      cout<< \"Total number of individual's observations = \"<<  y.n_elem <<endl;\n      cout<< \"Total number of SNPs = \"<<  s.n_elem <<endl;\n\n      cout<< \"# iterations = \"<< iterations <<endl;\n      cout<< \"TEST run = \"<< TEST <<endl;\n      cout<< \"Verbose = \"<< verbose <<endl;\n      cout<< \"Debug = \"<< debug <<endl;\n\n      cout<< \"----------\"<<endl;\n      cout<< \"Initializing ... \"<<endl;\n      std::chrono::time_point<std::chrono::system_clock> start, end; // start chronometer values\n      start = std::chrono::system_clock::now();\n\n\n     ///////////////////////////////////////////////////////////////////////////\n     // Deal with the matrix //\n     ///////////////////////////////////////////////////////////////////////////\n\n\n     cout<< \"Reading and subsetting genome matrix ... \"<<endl;\n\t   arma::Mat<double> X=BMsubset(A,n,m);\n\n     ///////////////////////////////////////////////////////////////////////////\n     // Setup MCMC //\n     ///////////////////////////////////////////////////////////////////////////\n\n      // Counter for printing\n      int counter = 0;\n      double percentunit = iterations/100;\n\n      // Initialize chain object\n      arma::mat s_chain(s.n_elem,iterations+1);\n      arma::mat par_chain(7, iterations+1);      /// update when adding new par\n\n      arma::vec  prob(iterations+1);\n      arma::vec  paccepts(iterations+1);\n\n\n      int naccepted=0;\n      double prob0;\n      double prob1;\n      double Paccept;\n    \tbool accept;\n\n      double selectionpar= s.n_elem ;\n      double globalpar= par_chain.n_rows;\n      double totpar= selectionpar + globalpar; // CHANGE WHEN ADDING MORE PARAMETERS\n      if(debug) cout << \"Total selection parameters = \" << (selectionpar) << endl;\n      if(debug) cout << \"Total global parameters = \" << (globalpar) << endl;\n      if(debug) cout << \"Total # of parameters = \" << (totpar) << endl;\n\n\n     \t///////////////////////////////////////////////////////////////////////////\n     // Setup MCMC conditions //\n     ///////////////////////////////////////////////////////////////////////////\n\n\n      // Proposals for variables\n      arma::vec  sproposal=s;\n      arma::vec gproposal(7); // Need to keep right order\n      gproposal(0)=b;\n      gproposal(1)=a;\n      gproposal(2)=p;\n      gproposal(3)=mu;\n      gproposal(4)=epi;\n      gproposal(5)=svar;\n      gproposal(6)=ss;\n      cout << \"First proposal of global paramenters: \"<< endl;\n      cout <<\"b = \"<< gproposal(0)<<endl;\n\t\t\tcout <<\"a = \" <<gproposal(1)<<endl;\n      cout <<\"p = \" <<gproposal(2)<<endl;\n      cout <<\"mu = \" <<gproposal(3)<<endl;\n      cout <<\"epi = \" <<gproposal(4)<<endl;\n      cout <<\"svar = \" <<gproposal(5)<<endl;\n      cout <<\"ss = \" <<gproposal(6)<<endl;\n      Rcpp::StringVector parnames(gproposal.n_elem);\n      parnames(0)=\"b\";\n      parnames(1)=\"a\";\n      parnames(2)=\"p\";\n      parnames(3)=\"mu\";\n      parnames(4)=\"epi\";\n      parnames(5)=\"svar\";\n      parnames(6)=\"ss\";\n\n\n      // Compute prob at first step\n      cout<< \"Start chains ...\"<<endl;\n      s_chain.col(0) = s; // set start as starting value\n      par_chain.col(0) = gproposal;\n\n       // Setup probability objects\n      LIKELIHOOD LL(y,h,X,Fitnessmode,TEST,false);\n      PRIOR Pri(0,svar, Priormode); // loggauss\n      // PRIOR Pri(min,max, Priormode); // uniform\n\n            // Proposal Prop(R,bw,nupdates,min,max,Proposalmode); // to implement R2\n      PROPOSAL Prop(bw,\n                    nupdates,\n                    min,\n                    max,\n                    Proposalmode);\n\t\t\tGPROPOSAL GProp(b,bmin,bmax,\n                   \t\ta, amin,amax,\n                   \t\tp,\n                   \t\tmu,mumin,mumax,\n                   \t\tepi,epimin,epimax,\n                   \t\tsvar,svarmin,svarmax);\n\n     \tpaccepts(0)=1;\n      cout<< \"Calculate posterior of starting point ...\" ;\n      prob(0) = Pri.fn(sproposal, gproposal(5),gproposal(6)) +\n      \t\t\t\t\tLL.fn(sproposal,\n\t \t\t\t\t\t\t\tgproposal(0),\n\t \t\t\t\t\t\t\tgproposal(1),\n\t \t\t\t\t\t\t\tgproposal(2),\n\t \t\t\t\t\t\t\tgproposal(3),\n\t \t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n      cout << prob(0) << endl;\n      if(isinf(prob(0))){\n      \tcout << \"Posterior is infinite!!!. Attempting change in stargin values\" << endl;\n      \tPROPOSAL Propattempt(bw,\n\t\t\t\t                     s.n_elem,\n\t\t\t\t                     min,\n\t\t\t\t                     max,\n\t\t\t\t                     Proposalmode);\n\t\t\t\twhile(!isinf(prob(0))){\n\t\t\t\t\tsproposal = Propattempt.fn(s);\n\t\t\t\t\tprob(0) =\n\t\t\t\t\t\t\t\t\t\tPri.fn(sproposal, gproposal(5),gproposal(6)) +\n\t\t\t\t\t\t\t\t\t\t// Pri.fn(sproposal) +  // Previous implementation\n\t\t\t\t\t\t\t\t\t\tLL.fn(sproposal,\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(0),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(1),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(2),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(3),\n \t\t\t\t\t\t\t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n      }\n\n\t\t  ///////////////////////////////////////////////////////////////////////////\n     // run MCMC  //\n     ///////////////////////////////////////////////////////////////////////////\n\n      cout<< \"Starting \"<< iterations<< \" MCMC iterations ...\"<<endl;\n      int counterupdate=0;\n\t\t\tint i;\n        for(i=0; i<iterations;i++){\n\n          // // Propose new s and new probability\n          if(verbose) cout<< \"Generating new proposal \"<<endl;\n\n          if(counterupdate <= selectionpar){\n            sproposal=Prop.fn(s_chain.col(i),gproposal(5));\n            counterupdate++;\n          }else if(counterupdate < totpar ){\n            gproposal=GProp.fn(par_chain.col(i));\n            counterupdate++;\n          }else{\n            counterupdate=0;\n          }\n\n          // Probabilities\n          if(verbose) cout<< \"Calculating next posterior \"<<endl;\n          prob0= prob(i);\n          prob1 = Pri.fn(sproposal, gproposal(5),gproposal(6))+\n          \t\t\t\tLL.fn(sproposal,\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(0),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(1),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(2),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(3),\n \t\t\t\t\t\t\t\t\t\t\t\tgproposal(4)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n    \t\t\t// if(debug) cout << prob1<< endl;\n\n            // Ratio of provabilities\n    \t\t\t\tPaccept= exp( prob1 - prob0);\n            accept = Rcpp::runif(1)(0)<Paccept;\n            if(verbose) cout<< \"Accept proposal \" << accept <<endl;\n\n            if(accept){\n              s_chain.col(i+1) = sproposal;\n              par_chain.col(i+1) = gproposal;\n\n              prob(i+1) = prob1;\n              paccepts(i+1) = Paccept;\n              naccepted++;\n            }else{\n              s_chain.col(i+1) = s_chain.col(i);\n              par_chain.col(i+1) = par_chain.col(i);\n\n              prob(i+1) = prob(i);\n              paccepts(i+1) = paccepts(i);\n            }\n\n            // Print row\n            if(counter > percentunit){\n              if(!debug & !sink2file) printProgress(i/iterations);\n              counter =0;\n            }else{\n              counter++;\n            }\n\n        }\n        printProgress(1);\n\n\t\t\t/////////\n      // End //\n      /////////\n      cout<< endl<< \"Summary:\"<<endl;\n      cout<< \"----------\"<<endl;\n      cout<< \"Acceptance ratio = \"<< naccepted / iterations << endl;\n      cout<< \"Final posterior = \"<< prob(iterations) << endl;\n      cout<< \"----------\"<<endl;\n      cout<<endl<< \"Done.\"<<endl;\n        end = std::chrono::system_clock::now();\n        std::chrono::duration<double> elapsed_seconds1 = end-start;\n        std::cout << \"elapsed time: \" << elapsed_seconds1.count() << \" seconds\" <<endl;\n\n     return List::create(Named(\"chain\") = s_chain.t(),\n                         Named(\"parchain\") = par_chain.t(),\n                         Named(\"parnames\") = parnames,\n                         Named(\"posterior\") = prob,\n                         Named(\"accept\") = paccepts);\n  }\n",
    "created" : 1515409041576.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "780550559",
    "id" : "60B7AA61",
    "lastKnownWriteTime" : 1515407361,
    "last_content_update" : 1515407361,
    "path" : "~/ebio/abt6_projects7/ath_1001G_field/gws/MCMCmean.cpp",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}